---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2018/8/16 21:32
---

local skynet       = require "skynet"
local logger       = require "logger"
local nodename     = skynet.getenv "nodename"

local cjson = require("cjson")
local cluster      = require "skynet.cluster"
local snax = require "skynet.snax"
local protoUtil    = require("protoUtil")
local serviceNames    = require("serviceNames")
local this = {}
function this.send(node, service, cmd, ...)
    if not node or not service or not cmd then
        return
    end
    if nodename == node then
        skynet.send(service, "lua", cmd, ...)
    else

        cluster.send(node, service, cmd, ...)
    end
end

function this.call(node, service, cmd, ...)
    if not service or not cmd then
        logger.Errorf("call node[%s] service[%s] cmd[%s] is nil",tostring(node), tostring(service), tostring(cmd))
        return false
    end
    if node == nil or node == "" or nodename == node then
        local args = {...}
        local ret1, ret2, ret3, ret4
        local ok, msg = xpcall(function()
            ret1, ret2, ret3, ret4 = skynet.call(service,"lua", cmd, table.unpack(args))
        end, debug.traceback)
        if not ok then
            logger.Errorf("call failed msg:%s service:%s cmd:%s",msg, tostring(service), cmd)
        end
        return ok, ret1, ret2, ret3, ret4
    else
        local args = {...}
        local ret1, ret2, ret3, ret4
        local ok, msg = xpcall(function()
            ret1, ret2, ret3, ret4 = cluster.call(node, service, cmd, table.unpack(args))
        end, debug.traceback)
        if not ok then
            logger.Errorf("context call failed node:%s service:%s cmd:%s", node, tostring(service), cmd)
        end
        return ok, ret1, ret2, ret3, ret4
    end
end

function this.rpsend(node, serv, cmd, ...)
    if not node or not serv or not cmd then
        error("rpsend fatal err")
    end
    return this.send(node, serv, "redirectS2S", cmd, ...)
end

function this.rpcall(node, serv, cmd, ...)
    if not node or not serv or not cmd then
        error("rpcall fatal err")
    end
    return this.call(node, serv, "redithisrectS2S", cmd, ...)
end

--打包发给客户端的数据
function this.pack(header, data)

    local buffer
    buffer = protoUtil.encodeData(header, data)
    return buffer
end

function this.sendMsgToClient(gSession,header,data)
    this.call(gSession.nodename, gSession.gate,
            "responseC2S", gSession.client, header, data)
end

function this.pushMsgToClient(gSession,header,data)
    this.call(gSession.nodename, gSession.gate,
            "pushS2C", gSession.client, header, data)
end
--function this.pushMsgToClientByRoleId(gSession,header,data)
--    this.call(gSession.nodename, gSession.gate,
--            "pushS2C", gSession.client, header, data)
--end

function this.callGameSession(gSession,...)
    local node = nodename
    local gate = serviceNames.wsgate

    if gSession then
        node = gSession.nodename or node
        gate = gSession.gate or gate
    end
    return this.call(node, gate,
            "callGameSession",...)
end



function this.callGate(gSession,cmd,...)
    local node = nodename
    local gate = serviceNames.wsgate

    if gSession then
        node = gSession.nodename or node
        gate = gSession.gate or gate
    end

    return this.call(node, gate,
            cmd,...)
end

---@param reqType string --请求类型 req 等待返回值  post
function this.snaxcall(node, name, address,reqType,func,...)
    local bind
    if node == nil or node == "" or nodename == node then -- 当前节点
        bind =  snax.queryservice(name)
    else
        bind = cluster.snax(node, name, address)
    end
    if not reqType or not func then
        return bind
    end
    if reqType == "req" then
        return bind[reqType][func](...)
    end

    bind[reqType][func](...)
    return nil

end

return this